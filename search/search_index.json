{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"djangorestframework-api-key API key permissions for Django REST Framework Introduction \u00b6 djangorestframework-api-key is a powerful library for allowing server-side clients to safely use your API. These clients are typically third-party backends and services (i.e. machines ) which do not have a user account but still need to interact with your API in a secure way. Features \u00b6 \u270c\ufe0f Simple to use : create, view and revoke API keys via the admin site, or use built-in helpers to create API keys programmatically. \ud83d\udd12 As secure as possible : API keys are treated with the same level of care than user passwords. They are hashed using the default password hasher before being stored in the database, and only visible at creation. \ud83c\udfa8 Customizable : satisfy specific business requirements by building your own customized API key models, permission classes and admin panels. (Currently in public beta.) Info There are important security aspects you need to consider before switching to an API key access control scheme. See Security caveats . Example use cases \u00b6 Using the built-in APIKey model, you can generate an API key and embed it in your frontend app server so that only it can access your API. By customizing API key models and permissions, you can associate API keys to an entity (e.g. a user, person, organization\u2026), and then build endpoints to allow them to manage their API keys. Quickstart \u00b6 Install the latest version with pip : pip install djangorestframework-api-key Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate To learn how to configure permissions and manage API keys, head to the User Guide .","title":"Home"},{"location":"#introduction","text":"djangorestframework-api-key is a powerful library for allowing server-side clients to safely use your API. These clients are typically third-party backends and services (i.e. machines ) which do not have a user account but still need to interact with your API in a secure way.","title":"Introduction"},{"location":"#features","text":"\u270c\ufe0f Simple to use : create, view and revoke API keys via the admin site, or use built-in helpers to create API keys programmatically. \ud83d\udd12 As secure as possible : API keys are treated with the same level of care than user passwords. They are hashed using the default password hasher before being stored in the database, and only visible at creation. \ud83c\udfa8 Customizable : satisfy specific business requirements by building your own customized API key models, permission classes and admin panels. (Currently in public beta.) Info There are important security aspects you need to consider before switching to an API key access control scheme. See Security caveats .","title":"Features"},{"location":"#example-use-cases","text":"Using the built-in APIKey model, you can generate an API key and embed it in your frontend app server so that only it can access your API. By customizing API key models and permissions, you can associate API keys to an entity (e.g. a user, person, organization\u2026), and then build endpoints to allow them to manage their API keys.","title":"Example use cases"},{"location":"#quickstart","text":"Install the latest version with pip : pip install djangorestframework-api-key Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate To learn how to configure permissions and manage API keys, head to the User Guide .","title":"Quickstart"},{"location":"guide/","text":"User Guide \u00b6 Getting started \u00b6 Installation \u00b6 Install from PyPI: pip install djangorestframework-api-key Note : djangorestframework-api-key requires Django REST Framework >= 3.8. Project setup \u00b6 Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate Setting permissions \u00b6 The HasAPIKey permission class protects a view behind API key authorization. You can set the permission globally: # settings.py REST_FRAMEWORK = { \"DEFAULT_PERMISSION_CLASSES\" : [ \"rest_framework_api_key.permissions.HasAPIKey\" , ] } or on a per-view basis: # views.py from rest_framework.views import APIView from rest_framework_api_key.permissions import HasAPIKey class UserListView ( APIView ): permission_classes = [ HasAPIKey ] # ... See also Setting the permission policy for more information on using permission classes in the Django REST Framework. Tip You can use the bitwise operators | and & to compose HasAPIKey with other permission classes and achieve more complex authorization behaviour. For example, to require a valid API key or authentication credentials, use: from rest_framework.permissions import IsAuthenticated from rest_framework_api_key.permissions import HasAPIKey # ... permission_classes = [ HasAPIKey | IsAuthenticated ] Making authorized requests \u00b6 Authorization header \u00b6 By default, clients must pass their API key via the Authorization header. It must be formatted as follows: Authorization: Api-Key ******** where ******** refers to the generated API key. To know under which conditions access is granted, please see Grant scheme . Custom header \u00b6 You can set the API_KEY_CUSTOM_HEADER setting to a non- None value to require clients to pass their API key in a custom header instead of the Authorization header. This is useful if you plan to use API keys AND an authentication scheme which already uses the Authorization header (e.g. token-based authentication). For example, if you set: # settings.py API_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\" then clients must make authorized requests using: X-Api-Key: ******** where ******** refers to the generated API key. Please refer to HttpRequest.META for more information on headers in Django. Creating and managing API keys \u00b6 Admin site \u00b6 When it is installed, djangorestframework-api-key adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys. Programmatic usage \u00b6 API keys can be created, viewed and revoked programmatically by manipulating the APIKey model. Note The examples below use the Django shell . You can view and query APIKey like any other model. For example, to know the total number of API keys: >>> from rest_framework_api_key.models import APIKey >>> APIKey . objects . count () 42 If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the .create_key() method on the APIKey objects manager instead of .create() : >>> from rest_framework_api_key.models import APIKey >>> api_key , key = APIKey . objects . create_key ( name = \"my-remote-service\" ) >>> # Proceed with `api_key` and `key`... Danger To prevent leaking API keys, you must only give the key to the client that triggered its generation . In particular, do not keep any trace of it on the server . Customization \u00b6 Warning This section documents functionality that is currently in public beta. To use it, install this package using: pip install \"djangorestframework-api-key==1.3.0.b0\" This package provides various customization APIs that allow you to extend its basic behavior. API key models \u00b6 If the built-in APIKey model doesn't fit your needs, you can create your own by subclassing AbstractAPIKey . This is particularly useful if you need to store extra information or link API keys to other models using a ForeignKey or a ManyToManyField . Example \u00b6 Here's how you could link API keys to an imaginary Organization model: # organizations/models.py from django.db import models from rest_framework_api_key.models import AbstractAPIKey class Organization ( models . Model ): name = models . CharField ( max_length = 128 ) active = models . BooleanField ( default = True ) class OrganizationAPIKey ( AbstractAPIKey ): organization = models . ForeignKey ( Organization , on_delete = models . CASCADE , related_name = \"api_keys\" , ) If you need to customize the model's Meta , it should inherit from AbstractAPIKey.Meta : class OrganizationAPIKey ( AbstractAPIKey ): # ... class Meta ( AbstractAPIKey . Meta ): verbose_name = \"Organization API key\" verbose_name_plural = \"Organization API keys\" Migrations \u00b6 Because AbstractAPIKey is an abstract model , the custom API key model will have its own table in the database. This means that you need to generate a migration and then apply it to be able to query the new API key model: python manage.py makemigrations python manage.py migrate Important If AbstractAPIKey changes (e.g. because of an update to djangorestframework-api-key ), you will need to generate and apply migrations again to account for these changes. Managers \u00b6 The APIKey model as well as custom API keys models inherited from AbstractAPIKey have a dedicated manager which is responsible for implementing .create_key() and other important behavior. As a result, if you want to build a custom API key manager, it should inherit from BaseAPIKeyManager instead of Django's Manager . Besides customization APIs that come with Django's managers , BaseAPIKeyManager gives you one extra hook: you can override .get_usable_keys() to customize which set of API keys clients can use in authorized requests. For example, here's how to restrict usable keys to those of active organizations only: class OrganizationAPIKeyManager ( BaseAPIKeyManager ): def get_usable_keys ( self ): return super () . get_usable_keys () . filter ( organization__active = True ) Check Note the call to the parent implementation using super() here. This is because .get_usable_keys() has some default behavior, including making sure that revoked API keys cannot be used. Tip You don't need to use a custom model to use a custom manager \u2014 it can be used on the built-in APIKey model as well. Admin panel \u00b6 If you'd like to view and manage your custom API key model via the Django admin site , you can create and register a subclass of APIKeyModelAdmin : # organizations/admin.py from django.contrib import admin from rest_framework_api_key.admin import APIKeyModelAdmin from .models import OrganizationAPIKey @admin.register ( OrganizationAPIKey ) class OrganizationAPIKeyModelAdmin ( APIKeyModelAdmin ): pass You can also customize any of the default attributes defined in APIKeyModelAdmin . For example, to display the organization's name in the list view, and allow searching OrganizationAPIKey instances by organization name while keeping the original search behavior, you can write: list_display = [ * APIKeyModelAdmin . list_display , \"organization__name\" ] search_fields = [ * APIKeyModelAdmin . search_fields , \"organization__name\" ] How can I display API keys on the detail page of a related model instance? In theory, this could be done using Django's InlineModelAdmin . However, due to the limitations of inlines, this cannot be easily achieved while correctly saving and displaying the generated key in the detail page of the related model. As an alternative, you can use the .list_filter class attribute to filter API keys by an identifying field on the related model. In the examples above, you could use organization__name to filter API keys by organization. Permission classes \u00b6 The built-in HasAPIKey permission class only checks against the built-in APIKey model. This means that if you use a custom API key model, you need to create a custom permission class for your application to validate API keys against it. You can do so by subclassing BaseHasAPIKey and specifying the .model class attribute: # organizations/permissions.py from rest_framework_api_key.permissions import BaseHasAPIKey from .models import OrganizationAPIKey class HasOrganizationAPIKey ( BaseHasAPIKey ): model = OrganizationAPIKey You can then use HasOrganizationAPIKey as described in Setting permissions . Tip If you need to customize .has_permission() or .has_object_permission() , feel free to read the source code . API key parsing \u00b6 By default, API key permission classes retrieve the API key from the Authorization header or a custom header, as described in Making authorized requests . You can override this behavior by redefining the .get_key() method on your custom permission class. It accepts the HttpRequest object as unique argument and should return the API key as an str if one was found, or None otherwise. For example, here's how you could retrieve the API key from a cookie: class HasOrganizationAPIKey ( BaseHasAPIKey ): # ... def get_key ( self , request ): return request . COOKIES . get ( \"api_key\" ) If your custom key parsing algorithm is complex, you may want to define it as a separate component. To do so, build a class which implements the .get() method with the same signature as .get_key() , and set it as the .key_parser : class CookieKeyParser : def get ( self , request ): cookie_name = getattr ( settings , \"API_KEY_COOKIE_NAME\" , \"api_key\" ) return request . COOKIES . get ( cookie_name ) class HasOrganizationAPIKey ( BaseHasAPIKey ): # ... key_parser = CookieKeyParser () Key generation \u00b6 Warning This is an advanced topic . Customizing the key generation algorithm must be done with care to prevent security issues. If you proceed, it is best to customize key generation with a clean database state , that is before running initial migrations , and more importantly before any API key is created . This package ships with a key generation algorithm based on Django's password hashing infrastructure (see also Security ). The .key_generator attribute on BaseAPIKeyManager allows you to customize key generation. For example, you can customize the length of the prefix and secret key using: from rest_framework_api_key.models import BaseAPIKeyManager from rest_framework_api_key.crypto import KeyGenerator class OrganizationAPIKeyManager ( BaseAPIKeyManager ): key_generator = KeyGenerator ( prefix_length = 8 , secret_key_length = 32 ) # Default values class OrganizationAPIKey ( AbstractAPIKey ): objects = OrganizationAPIKeyManager () # ... If you want to replace the key generation algorithm entirely, you can create your own KeyGenerator class. It must implement the .generate() and .verify() methods. At this point, it's probably best to read the source code for the built-in KeyGenerator . Check If the signature of your .generate() method is different from the built-in one, you'll need to override .assign_key() in your custom API key manager as well. Likewise, if .verify() must accept anything else than the key and hashed_key , you'll need to override .is_valid() on your custom API key model. See models.py for the source code of BaseAPIKeyManager .","title":"User Guide"},{"location":"guide/#user-guide","text":"","title":"User Guide"},{"location":"guide/#getting-started","text":"","title":"Getting started"},{"location":"guide/#installation","text":"Install from PyPI: pip install djangorestframework-api-key Note : djangorestframework-api-key requires Django REST Framework >= 3.8.","title":"Installation"},{"location":"guide/#project-setup","text":"Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate","title":"Project setup"},{"location":"guide/#setting-permissions","text":"The HasAPIKey permission class protects a view behind API key authorization. You can set the permission globally: # settings.py REST_FRAMEWORK = { \"DEFAULT_PERMISSION_CLASSES\" : [ \"rest_framework_api_key.permissions.HasAPIKey\" , ] } or on a per-view basis: # views.py from rest_framework.views import APIView from rest_framework_api_key.permissions import HasAPIKey class UserListView ( APIView ): permission_classes = [ HasAPIKey ] # ... See also Setting the permission policy for more information on using permission classes in the Django REST Framework. Tip You can use the bitwise operators | and & to compose HasAPIKey with other permission classes and achieve more complex authorization behaviour. For example, to require a valid API key or authentication credentials, use: from rest_framework.permissions import IsAuthenticated from rest_framework_api_key.permissions import HasAPIKey # ... permission_classes = [ HasAPIKey | IsAuthenticated ]","title":"Setting permissions"},{"location":"guide/#making-authorized-requests","text":"","title":"Making authorized requests"},{"location":"guide/#authorization-header","text":"By default, clients must pass their API key via the Authorization header. It must be formatted as follows: Authorization: Api-Key ******** where ******** refers to the generated API key. To know under which conditions access is granted, please see Grant scheme .","title":"Authorization header"},{"location":"guide/#custom-header","text":"You can set the API_KEY_CUSTOM_HEADER setting to a non- None value to require clients to pass their API key in a custom header instead of the Authorization header. This is useful if you plan to use API keys AND an authentication scheme which already uses the Authorization header (e.g. token-based authentication). For example, if you set: # settings.py API_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\" then clients must make authorized requests using: X-Api-Key: ******** where ******** refers to the generated API key. Please refer to HttpRequest.META for more information on headers in Django.","title":"Custom header"},{"location":"guide/#creating-and-managing-api-keys","text":"","title":"Creating and managing API keys"},{"location":"guide/#admin-site","text":"When it is installed, djangorestframework-api-key adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys.","title":"Admin site"},{"location":"guide/#programmatic-usage","text":"API keys can be created, viewed and revoked programmatically by manipulating the APIKey model. Note The examples below use the Django shell . You can view and query APIKey like any other model. For example, to know the total number of API keys: >>> from rest_framework_api_key.models import APIKey >>> APIKey . objects . count () 42 If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the .create_key() method on the APIKey objects manager instead of .create() : >>> from rest_framework_api_key.models import APIKey >>> api_key , key = APIKey . objects . create_key ( name = \"my-remote-service\" ) >>> # Proceed with `api_key` and `key`... Danger To prevent leaking API keys, you must only give the key to the client that triggered its generation . In particular, do not keep any trace of it on the server .","title":"Programmatic usage"},{"location":"guide/#customization","text":"Warning This section documents functionality that is currently in public beta. To use it, install this package using: pip install \"djangorestframework-api-key==1.3.0.b0\" This package provides various customization APIs that allow you to extend its basic behavior.","title":"Customization"},{"location":"guide/#api-key-models","text":"If the built-in APIKey model doesn't fit your needs, you can create your own by subclassing AbstractAPIKey . This is particularly useful if you need to store extra information or link API keys to other models using a ForeignKey or a ManyToManyField .","title":"API key models"},{"location":"guide/#example","text":"Here's how you could link API keys to an imaginary Organization model: # organizations/models.py from django.db import models from rest_framework_api_key.models import AbstractAPIKey class Organization ( models . Model ): name = models . CharField ( max_length = 128 ) active = models . BooleanField ( default = True ) class OrganizationAPIKey ( AbstractAPIKey ): organization = models . ForeignKey ( Organization , on_delete = models . CASCADE , related_name = \"api_keys\" , ) If you need to customize the model's Meta , it should inherit from AbstractAPIKey.Meta : class OrganizationAPIKey ( AbstractAPIKey ): # ... class Meta ( AbstractAPIKey . Meta ): verbose_name = \"Organization API key\" verbose_name_plural = \"Organization API keys\"","title":"Example"},{"location":"guide/#migrations","text":"Because AbstractAPIKey is an abstract model , the custom API key model will have its own table in the database. This means that you need to generate a migration and then apply it to be able to query the new API key model: python manage.py makemigrations python manage.py migrate Important If AbstractAPIKey changes (e.g. because of an update to djangorestframework-api-key ), you will need to generate and apply migrations again to account for these changes.","title":"Migrations"},{"location":"guide/#managers","text":"The APIKey model as well as custom API keys models inherited from AbstractAPIKey have a dedicated manager which is responsible for implementing .create_key() and other important behavior. As a result, if you want to build a custom API key manager, it should inherit from BaseAPIKeyManager instead of Django's Manager . Besides customization APIs that come with Django's managers , BaseAPIKeyManager gives you one extra hook: you can override .get_usable_keys() to customize which set of API keys clients can use in authorized requests. For example, here's how to restrict usable keys to those of active organizations only: class OrganizationAPIKeyManager ( BaseAPIKeyManager ): def get_usable_keys ( self ): return super () . get_usable_keys () . filter ( organization__active = True ) Check Note the call to the parent implementation using super() here. This is because .get_usable_keys() has some default behavior, including making sure that revoked API keys cannot be used. Tip You don't need to use a custom model to use a custom manager \u2014 it can be used on the built-in APIKey model as well.","title":"Managers"},{"location":"guide/#admin-panel","text":"If you'd like to view and manage your custom API key model via the Django admin site , you can create and register a subclass of APIKeyModelAdmin : # organizations/admin.py from django.contrib import admin from rest_framework_api_key.admin import APIKeyModelAdmin from .models import OrganizationAPIKey @admin.register ( OrganizationAPIKey ) class OrganizationAPIKeyModelAdmin ( APIKeyModelAdmin ): pass You can also customize any of the default attributes defined in APIKeyModelAdmin . For example, to display the organization's name in the list view, and allow searching OrganizationAPIKey instances by organization name while keeping the original search behavior, you can write: list_display = [ * APIKeyModelAdmin . list_display , \"organization__name\" ] search_fields = [ * APIKeyModelAdmin . search_fields , \"organization__name\" ] How can I display API keys on the detail page of a related model instance? In theory, this could be done using Django's InlineModelAdmin . However, due to the limitations of inlines, this cannot be easily achieved while correctly saving and displaying the generated key in the detail page of the related model. As an alternative, you can use the .list_filter class attribute to filter API keys by an identifying field on the related model. In the examples above, you could use organization__name to filter API keys by organization.","title":"Admin panel"},{"location":"guide/#permission-classes","text":"The built-in HasAPIKey permission class only checks against the built-in APIKey model. This means that if you use a custom API key model, you need to create a custom permission class for your application to validate API keys against it. You can do so by subclassing BaseHasAPIKey and specifying the .model class attribute: # organizations/permissions.py from rest_framework_api_key.permissions import BaseHasAPIKey from .models import OrganizationAPIKey class HasOrganizationAPIKey ( BaseHasAPIKey ): model = OrganizationAPIKey You can then use HasOrganizationAPIKey as described in Setting permissions . Tip If you need to customize .has_permission() or .has_object_permission() , feel free to read the source code .","title":"Permission classes"},{"location":"guide/#api-key-parsing","text":"By default, API key permission classes retrieve the API key from the Authorization header or a custom header, as described in Making authorized requests . You can override this behavior by redefining the .get_key() method on your custom permission class. It accepts the HttpRequest object as unique argument and should return the API key as an str if one was found, or None otherwise. For example, here's how you could retrieve the API key from a cookie: class HasOrganizationAPIKey ( BaseHasAPIKey ): # ... def get_key ( self , request ): return request . COOKIES . get ( \"api_key\" ) If your custom key parsing algorithm is complex, you may want to define it as a separate component. To do so, build a class which implements the .get() method with the same signature as .get_key() , and set it as the .key_parser : class CookieKeyParser : def get ( self , request ): cookie_name = getattr ( settings , \"API_KEY_COOKIE_NAME\" , \"api_key\" ) return request . COOKIES . get ( cookie_name ) class HasOrganizationAPIKey ( BaseHasAPIKey ): # ... key_parser = CookieKeyParser ()","title":"API key parsing"},{"location":"guide/#key-generation","text":"Warning This is an advanced topic . Customizing the key generation algorithm must be done with care to prevent security issues. If you proceed, it is best to customize key generation with a clean database state , that is before running initial migrations , and more importantly before any API key is created . This package ships with a key generation algorithm based on Django's password hashing infrastructure (see also Security ). The .key_generator attribute on BaseAPIKeyManager allows you to customize key generation. For example, you can customize the length of the prefix and secret key using: from rest_framework_api_key.models import BaseAPIKeyManager from rest_framework_api_key.crypto import KeyGenerator class OrganizationAPIKeyManager ( BaseAPIKeyManager ): key_generator = KeyGenerator ( prefix_length = 8 , secret_key_length = 32 ) # Default values class OrganizationAPIKey ( AbstractAPIKey ): objects = OrganizationAPIKeyManager () # ... If you want to replace the key generation algorithm entirely, you can create your own KeyGenerator class. It must implement the .generate() and .verify() methods. At this point, it's probably best to read the source code for the built-in KeyGenerator . Check If the signature of your .generate() method is different from the built-in one, you'll need to override .assign_key() in your custom API key manager as well. Likewise, if .verify() must accept anything else than the key and hashed_key , you'll need to override .is_valid() on your custom API key model. See models.py for the source code of BaseAPIKeyManager .","title":"Key generation"},{"location":"security/","text":"Security \u00b6 Key generation scheme \u00b6 An API key is composed of two items: A prefix P , which is a generated string of 8 characters. A secret key SK , which is a generated string of 32 characters. The generated key that clients use to make authorized requests is GK = P.SK . It is treated with the same level of care than passwords: Only a hashed version is stored in the database. The hash is computed using the default password hasher. 1 The generated key is shown only once to the client upon API key creation. Grant scheme \u00b6 Access is granted if and only if all of the following is true: The configured API key header is present and correctly formatted. 2 A usable API key with the prefix of the given key exists in the database. 3 The hash of the given key matches that of the API key. Caveats \u00b6 API keys \u2260 Security : depending on your situation, you should probably not rely on API keys only to authenticate/authorize your clients. Using API keys shifts the responsability of Information Security on your clients . This induces risks, especially if detaining an API key gives access to confidential information or write operations. For example, an attacker could impersonate clients if they let their API keys leak. As a best practice, you should apply the Principle of Least Privilege : allow only those who require resources to access those specific resources. In other words: if your client needs to access an endpoint, add API permissions on that endpoint only instead of the whole API. Besides, it is highly recommended to serve the API over HTTPS to ensure the confidentiality of API keys passed in requests. Act responsibly! All hashers provided by Django should be supported. djangorestframework-api-key is tested against the default list of PASSWORD_HASHERS . See also How Django stores passwords for more information. \u21a9 To customize this behavior, see API key parsing . \u21a9 Only unrevoked keys are usable by default, but this can be customized with a custom manager . \u21a9","title":"Security"},{"location":"security/#security","text":"","title":"Security"},{"location":"security/#key-generation-scheme","text":"An API key is composed of two items: A prefix P , which is a generated string of 8 characters. A secret key SK , which is a generated string of 32 characters. The generated key that clients use to make authorized requests is GK = P.SK . It is treated with the same level of care than passwords: Only a hashed version is stored in the database. The hash is computed using the default password hasher. 1 The generated key is shown only once to the client upon API key creation.","title":"Key generation scheme"},{"location":"security/#grant-scheme","text":"Access is granted if and only if all of the following is true: The configured API key header is present and correctly formatted. 2 A usable API key with the prefix of the given key exists in the database. 3 The hash of the given key matches that of the API key.","title":"Grant scheme"},{"location":"security/#caveats","text":"API keys \u2260 Security : depending on your situation, you should probably not rely on API keys only to authenticate/authorize your clients. Using API keys shifts the responsability of Information Security on your clients . This induces risks, especially if detaining an API key gives access to confidential information or write operations. For example, an attacker could impersonate clients if they let their API keys leak. As a best practice, you should apply the Principle of Least Privilege : allow only those who require resources to access those specific resources. In other words: if your client needs to access an endpoint, add API permissions on that endpoint only instead of the whole API. Besides, it is highly recommended to serve the API over HTTPS to ensure the confidentiality of API keys passed in requests. Act responsibly! All hashers provided by Django should be supported. djangorestframework-api-key is tested against the default list of PASSWORD_HASHERS . See also How Django stores passwords for more information. \u21a9 To customize this behavior, see API key parsing . \u21a9 Only unrevoked keys are usable by default, but this can be customized with a custom manager . \u21a9","title":"Caveats"}]}