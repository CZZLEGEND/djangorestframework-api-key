{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"djangorestframework-api-key API key permissions for Django REST Framework \u00b6 Migrating from 0.x? Read the release notes . djangorestframework-api-key allows server-side clients to safely use your API . Server-side clients are third-party backends and services (i.e. machines ) which do not have a user account but still need to interact with your API in a secure way. Intended to be: \u270c\ufe0f Simple to use : create, view and revoke API keys via the admin site, or use built-in helpers to create API keys programmatically. \ud83d\udd12 As secure as possible : API keys are treated with the same level of care than user passwords. They are hashed using the default password hasher before being stored in the database, and only visible at creation. Note : there are important security aspects you need to consider before switching to an API key access control scheme. See Security caveats . Quickstart \u00b6 Install the latest version with pip : pip install djangorestframework-api-key Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... 'rest_framework' , 'rest_framework_api_key' , ] Run the included migrations: python manage.py migrate To learn how to configure permissions and manage API keys, read the User Guide .","title":"Home"},{"location":"#api-key-permissions-for-django-rest-framework","text":"Migrating from 0.x? Read the release notes . djangorestframework-api-key allows server-side clients to safely use your API . Server-side clients are third-party backends and services (i.e. machines ) which do not have a user account but still need to interact with your API in a secure way. Intended to be: \u270c\ufe0f Simple to use : create, view and revoke API keys via the admin site, or use built-in helpers to create API keys programmatically. \ud83d\udd12 As secure as possible : API keys are treated with the same level of care than user passwords. They are hashed using the default password hasher before being stored in the database, and only visible at creation. Note : there are important security aspects you need to consider before switching to an API key access control scheme. See Security caveats .","title":"API key permissions for Django REST Framework"},{"location":"#quickstart","text":"Install the latest version with pip : pip install djangorestframework-api-key Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... 'rest_framework' , 'rest_framework_api_key' , ] Run the included migrations: python manage.py migrate To learn how to configure permissions and manage API keys, read the User Guide .","title":"Quickstart"},{"location":"guide/","text":"User Guide \u00b6 Getting started \u00b6 Installation \u00b6 Install from PyPI: pip install djangorestframework-api-key Note : djangorestframework-api-key requires Django REST Framework >= 3.8. Project setup \u00b6 Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... 'rest_framework' , 'rest_framework_api_key' , ] Run the included migrations: python manage.py migrate Setting permissions \u00b6 The HasAPIKey permission class protects a view behind API key authorization. You can set the permission globally: # settings.py REST_FRAMEWORK = { 'DEFAULT_PERMISSION_CLASSES' : [ 'rest_framework_api_key.permissions.HasAPIKey' , ] } or on a per-view basis: # views.py from rest_framework.views import APIView from rest_framework_api_key.permissions import HasAPIKey class UserListView ( APIView ): permission_classes = [ HasAPIKey ] # ... See also Setting the permission policy for more information on using permission classes in the Django REST Framework. Tip You can use the bitwise operators | and & to compose HasAPIKey with other permission classes and achieve more complex authorization behaviour. For example, to require a valid API key or authentication credentials, use: from rest_framework.permissions import IsAuthenticated from rest_framework_api_key.permissions import HasAPIKey # ... permission_classes = [ HasAPIKey | IsAuthenticated ] Making authorized requests \u00b6 Authorization header \u00b6 By default, clients must pass their API key via the Authorization header. It must be formatted as follows: Authorization: Api-Key ******** where ******** refers to the generated API key. To know under which conditions access is granted, please see Grant scheme . Custom header \u00b6 You can set the API_KEY_CUSTOM_HEADER setting to a non- None value to require clients to pass their API key in a custom header instead of the Authorization header. This is useful if you plan to use API keys AND an authentication scheme which already uses the Authorization header (e.g. token-based authentication). For example, if you set: # settings.py API_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\" then clients must make authorized requests using: X-Api-Key: ******** where ******** refers to the generated API key. Please refer to HttpRequest.META for more information on headers in Django. Creating and managing API keys \u00b6 Admin site \u00b6 When it is installed, djangorestframework-api-key adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys. Programmatic usage (advanced) \u00b6 API keys can be created, viewed and revoked programmatically by manipulating the APIKey model. The examples below use the Django shell . You can view and query APIKey like any other model. For example, to know the number of active (unrevoked) API keys: >>> from rest_framework_api_key.models import APIKey >>> APIKey . objects . filter ( revoked = False ) . count () 42 If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the .create_key() method on the APIKey objects manager instead of .create() : >>> from rest_framework_api_key.models import APIKey >>> api_key , generated_key = APIKey . objects . create_key ( name = \"Backend API\" ) >>> # Proceed with `api_key` and `generated_key`... Danger : to preserve confidentiality, give the generated key to the client only , and do not keep any trace of it on the server afterwards.","title":"User Guide"},{"location":"guide/#user-guide","text":"","title":"User Guide"},{"location":"guide/#getting-started","text":"","title":"Getting started"},{"location":"guide/#installation","text":"Install from PyPI: pip install djangorestframework-api-key Note : djangorestframework-api-key requires Django REST Framework >= 3.8.","title":"Installation"},{"location":"guide/#project-setup","text":"Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... 'rest_framework' , 'rest_framework_api_key' , ] Run the included migrations: python manage.py migrate","title":"Project setup"},{"location":"guide/#setting-permissions","text":"The HasAPIKey permission class protects a view behind API key authorization. You can set the permission globally: # settings.py REST_FRAMEWORK = { 'DEFAULT_PERMISSION_CLASSES' : [ 'rest_framework_api_key.permissions.HasAPIKey' , ] } or on a per-view basis: # views.py from rest_framework.views import APIView from rest_framework_api_key.permissions import HasAPIKey class UserListView ( APIView ): permission_classes = [ HasAPIKey ] # ... See also Setting the permission policy for more information on using permission classes in the Django REST Framework. Tip You can use the bitwise operators | and & to compose HasAPIKey with other permission classes and achieve more complex authorization behaviour. For example, to require a valid API key or authentication credentials, use: from rest_framework.permissions import IsAuthenticated from rest_framework_api_key.permissions import HasAPIKey # ... permission_classes = [ HasAPIKey | IsAuthenticated ]","title":"Setting permissions"},{"location":"guide/#making-authorized-requests","text":"","title":"Making authorized requests"},{"location":"guide/#authorization-header","text":"By default, clients must pass their API key via the Authorization header. It must be formatted as follows: Authorization: Api-Key ******** where ******** refers to the generated API key. To know under which conditions access is granted, please see Grant scheme .","title":"Authorization header"},{"location":"guide/#custom-header","text":"You can set the API_KEY_CUSTOM_HEADER setting to a non- None value to require clients to pass their API key in a custom header instead of the Authorization header. This is useful if you plan to use API keys AND an authentication scheme which already uses the Authorization header (e.g. token-based authentication). For example, if you set: # settings.py API_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\" then clients must make authorized requests using: X-Api-Key: ******** where ******** refers to the generated API key. Please refer to HttpRequest.META for more information on headers in Django.","title":"Custom header"},{"location":"guide/#creating-and-managing-api-keys","text":"","title":"Creating and managing API keys"},{"location":"guide/#admin-site","text":"When it is installed, djangorestframework-api-key adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys.","title":"Admin site"},{"location":"guide/#programmatic-usage-advanced","text":"API keys can be created, viewed and revoked programmatically by manipulating the APIKey model. The examples below use the Django shell . You can view and query APIKey like any other model. For example, to know the number of active (unrevoked) API keys: >>> from rest_framework_api_key.models import APIKey >>> APIKey . objects . filter ( revoked = False ) . count () 42 If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the .create_key() method on the APIKey objects manager instead of .create() : >>> from rest_framework_api_key.models import APIKey >>> api_key , generated_key = APIKey . objects . create_key ( name = \"Backend API\" ) >>> # Proceed with `api_key` and `generated_key`... Danger : to preserve confidentiality, give the generated key to the client only , and do not keep any trace of it on the server afterwards.","title":"Programmatic usage (advanced)"},{"location":"security/","text":"Security \u00b6 Key generation scheme \u00b6 An API key is composed of two items: A prefix P , which is a generated string of 8 characters. A secret key SK , which is a generated string of 32 characters. The generated key that clients use to make authorized requests is GK = P.SK . It is treated with the same level of care than passwords: Only a hashed version is stored in the database. The hash is computed using the default password hasher. 1 The generated key is shown only once to the client upon API key creation. Grant scheme \u00b6 Access is granted if and only if all of the following is true: The configured API key header is present and correctly formatted. A usable API key with the prefix of the given key exists in the database. The hash of the given key matches that of the API key. Caveats \u00b6 API keys \u2260 Security : depending on your situation, you should probably not rely on API keys only to authenticate/authorize your clients. Using API keys shifts the responsability of Information Security on your clients . This induces risks, especially if detaining an API key gives access to confidential information or write operations. For example, an attacker could impersonate clients if they let their API keys leak. As a best practice, you should apply the Principle of Least Privilege : allow only those who require resources to access those specific resources. In other words: if your client needs to access an endpoint, add API permissions on that endpoint only instead of the whole API. Besides, it is highly recommended to serve the API over HTTPS to ensure the confidentiality of API keys passed in requests. Act responsibly! All hashers provided by Django should be supported. djangorestframework-api-key is tested against the default list of PASSWORD_HASHERS . See also How Django stores passwords for more information. \u21a9","title":"Security"},{"location":"security/#security","text":"","title":"Security"},{"location":"security/#key-generation-scheme","text":"An API key is composed of two items: A prefix P , which is a generated string of 8 characters. A secret key SK , which is a generated string of 32 characters. The generated key that clients use to make authorized requests is GK = P.SK . It is treated with the same level of care than passwords: Only a hashed version is stored in the database. The hash is computed using the default password hasher. 1 The generated key is shown only once to the client upon API key creation.","title":"Key generation scheme"},{"location":"security/#grant-scheme","text":"Access is granted if and only if all of the following is true: The configured API key header is present and correctly formatted. A usable API key with the prefix of the given key exists in the database. The hash of the given key matches that of the API key.","title":"Grant scheme"},{"location":"security/#caveats","text":"API keys \u2260 Security : depending on your situation, you should probably not rely on API keys only to authenticate/authorize your clients. Using API keys shifts the responsability of Information Security on your clients . This induces risks, especially if detaining an API key gives access to confidential information or write operations. For example, an attacker could impersonate clients if they let their API keys leak. As a best practice, you should apply the Principle of Least Privilege : allow only those who require resources to access those specific resources. In other words: if your client needs to access an endpoint, add API permissions on that endpoint only instead of the whole API. Besides, it is highly recommended to serve the API over HTTPS to ensure the confidentiality of API keys passed in requests. Act responsibly! All hashers provided by Django should be supported. djangorestframework-api-key is tested against the default list of PASSWORD_HASHERS . See also How Django stores passwords for more information. \u21a9","title":"Caveats"}]}